// BPF JavaScript library version 0.9
// (c) Nick Polyak 2012 - http://awebpros.com/
// License: Code Project Open License (CPOL) 1.92(http://www.codeproject.com/info/cpol10.aspx)
//
// short overview of copyright rules:
// 1. you can use this framework in any commercial or non-commercial 
//    product as long as you retain this copyright message
// 2. Do not blame the author(s) of this software if something goes wrong. 
// 
// Also as a courtesy, please, mention this software in any documentation for the 
// products that use it.

var bpf = bpf || {}; bpf.nav = bpf.nav || {}, bpf.nav.CheckboxNavAdaptor = function (n, t) { var i = this, r = n, o = t; i.onSelectionChanged = new SimpleEvent; var f = function () { return r[0] }, u = function (n) { return n === !0 ? "selected_" + t : "unselected_" + t }, e = function () { return u(f().checked) }; r.bind("change", function () { i.fireSelectedHashChanged() }), i.fireSelectedHashChanged = function () { i.onSelectionChanged.fire(i, i.getSelectedKey()) }, i.getSelectedKey = function () { return e() }, i.select = function (n) { var t; n === u(!0) ? t = !0 : n === u(!1) && (t = !1), (t || t === !1) && (f().checked = t, r.trigger("change")) }, i.unselect = function () { } }, bpf = bpf || {}, bpf.nav = bpf.nav || {}, bpf.nav.JQTabsNavAdaptor = function (n) { var t = this, r = function () { return bpf.utils.stripFirstPound(n.find(".ui-tabs-active a").attr("href")) }, i; t.onSelectionChanged = new SimpleEvent, n.bind("tabsselect", function (r, u) { var f = n[0]; r.target === f && (t.selectedKey = bpf.utils.stripFirstPound(u.tab.hash), i()) }), i = function () { t.onSelectionChanged.fire(t, t.selectedKey) }, t.getSelectedKey = function () { if (t.selectedKey) return t.selectedKey; return r() }, t.select = function (t) { n.tabs("select", t) }, t.unselect = function () { } }, bpf = bpf || {}, bpf.nav = bpf.nav || {}, bpf.nav.KoObservableNavAdaptor = function (n, t, i) { var r = this, e = !0, u, o = t, s = i, f; r.onSelectionChanged = new SimpleEvent, n.subscribe(function (n) { u !== n && (u = n, f()) }), f = function () { r.onSelectionChanged.fire(r, r.selectedKey) }, r.getSelectedKey = function () { if (u) return s(u) }, r.select = function (t) { e = !1, u = o(t), u ? n(u) : r.unselect() }, r.unselect = function () { u = null, n("") } }, bpf = bpf || {}, bpf.nav = bpf.nav || {}, bpf.nav.Node = function (n, t) { var i = this, r; bpf.nav.NodeBase.call(i, t), r = function (n) { i.data = n, n.onSelectionChanged.addSimpleEventHandler(function () { i.fireSelectionChanged() }) }, r(n), i.addChildren = function (n, t, r) { var u = n(); return _(u).each(function (n) { var u = r(n), f = t(n); i.addChild(u, f) }), _childNodes }, i.getSelectedKey = function () { return i.data.getSelectedKey() }, i.unselect = function () { i.data.unselect() }, i.chainUnselect = function () { var n = i.getSelectedChild(); n && n.chainUnselect(), i.unselect() }, i.select = function (n) { i.getSelectedKey() !== n && i.data.select(n) }, i.getSelectedChild = function () { return i.getChild(i.getSelectedKey()) }, i.setSelectedKeySegmentsRecursive = function (n) { var u = [".", "(", ")"], t, r; return (key = n.getStrUpTo(u, function (n, i) { r = n, t = i }), i.select(key), childNode = i.getSelectedChild(), !childNode) ? t : (r === "." || r === "(" ? t = childNode.setSelectedKeySegmentsRecursive(t) : childNode.chainUnselect(), r === ")" && (t = r + t), t) }, i.getUrlRecursive = function () { var n = "", r = i.data.getSelectedKey(), t; if (r) n += r; else return n; return t = i.getSelectedChild(), t && (n += bpf.utils.segmentSeparationCharacter + t.getUrlRecursive()), n } }, bpf = bpf || {}, bpf.nav = bpf.nav || {}, bpf.nav.NodeBase = function (n) { var t = this, u = new SimpleEvent, r = n, i; t.setParentNode = function (n) { r = n }, t.getOnSelectionChangedEvent = function () { return u }, t.fireSelectionChanged = function () { r ? r.fireSelectionChanged() : u.fire() }, t.addChildNode = function (n, r) { i || (i = new bpf.utils.OrderedMap), r.setParentNode(t), i.add(n, r) }, t.addChild = function (n, i) { var r = new bpf.nav.Node(i); return t.addChildNode(n, r), r }, t.getChild = function (n) { if (n) return i ? i.objByKey(n) : void 0 }, t.getChildren = function () { return i }, t.getTotalHash = function () { return t.getUrlRecursive() + bpf.utils.segmentSeparationCharacter }, t.setSelectedKeySegments = function (n) { n = bpf.utils.stripFirstPound(n), n = bpf.utils.stripTrailingDot(n), t.setSelectedKeySegmentsRecursive(n) } }, bpf.nav.setTotalHash = function (n) { window.location.hash = n.getTotalHash() }, bpf.nav.setKeySegmentToHash = function (n) { var t = n.getTotalHash(); return t === window.location.hash ? !1 : (n.setSelectedKeySegments(window.location.hash), bpf.nav.setTotalHash(n), !0) }, bpf = bpf || {}, bpf.nav = bpf.nav || {}, bpf.nav.ProductNode = function (n) { var t = this; bpf.nav.NodeBase.call(t, n), t.chainUnselect = function () { for (var r = t.getChildren(), i, n = r.getIterator(); n.isCurrentValid(); n.moveToNext()) i = n.current(), i.chainUnselect() }, t.setSelectedKeySegmentsRecursive = function (n) { for (var i = n, u = t.getChildren(), e = u.getMapClone(), f, o, s, r; i.length > 0; ) { if (i.startsWith(")")) return i.removePrefix(")"); if (!i.startsWith("(")) return; i = i.removePrefix("("), f = i.getStrUpTo("/", function (n, t) { i = t }), e.removeKey(f), r = u.objByKey(f), i = r.setSelectedKeySegmentsRecursive(i) } o = e.unextendObj(); for (s in o) r = u.objByKey(s), r.chainUnselect(); return i }, t.getUrlRecursive = function () { for (var i = "", u = t.getChildren(), n = u.getIterator(); n.isCurrentValid(); n.moveToNext()) { var f = n.currentKey(), e = n.current(), r = e.getUrlRecursive(); r && (i += "(" + f + "/" + r + ")") } return i } }
//@ sourceMappingURL=bpf_nav.min.js.map